<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>R-Type documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="build.html"><strong aria-hidden="true">1.</strong> Build Project</a></li><li class="chapter-item expanded "><a href="technical_choices.html"><strong aria-hidden="true">2.</strong> Technical Choices</a></li><li class="chapter-item expanded "><a href="client/index.html"><strong aria-hidden="true">3.</strong> Client</a></li><li class="chapter-item expanded "><a href="server/index.html"><strong aria-hidden="true">4.</strong> Server</a></li><li class="chapter-item expanded "><a href="network/index.html"><strong aria-hidden="true">5.</strong> Network</a></li><li class="chapter-item expanded "><a href="ecs.html"><strong aria-hidden="true">6.</strong> Develop with our ECS</a></li><li class="chapter-item expanded "><a href="graphical_library/index.html"><strong aria-hidden="true">7.</strong> Graphical Library</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">R-Type documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="r-type"><a class="header" href="#r-type">R-Type</a></h1>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>See the documentation <a href="https://manigillier.github.io/rtype">here</a>.</p>
<h2 id="how-to-get-started"><a class="header" href="#how-to-get-started">How to get started</a></h2>
<pre><code class="language-bash">make release
</code></pre>
<p>Two binaries will then be created :</p>
<ul>
<li><code>r-type_client</code>, graphical client.</li>
<li><code>r-type_server</code>, server</li>
</ul>
<p><code>./r-type_client IP PORT [-d]</code>
<code>./r-type_server -p PORT [-l TICKSPEED] [-d]</code></p>
<h2 id="authors"><a class="header" href="#authors">Authors</a></h2>
<ul>
<li>Mani Gillier</li>
<li>Rayane El Janati El Idrissi</li>
<li>Hugo Poggetti</li>
<li>Maxime Huet</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-project"><a class="header" href="#build-project">Build project</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<ul>
<li>make</li>
<li>cmake =&gt; 3.15</li>
<li>c++20 compiler</li>
<li><a href="https://github.com/raysan5/raylib/wiki/raylib-dependencies">Raylib dependencies</a></li>
<li>PThreads (POSIX threads)</li>
</ul>
<h2 id="package-manager"><a class="header" href="#package-manager">Package manager</a></h2>
<ul>
<li><a href="https://github.com/cpm-cmake/CPM.cmake">cmake cpm</a></li>
</ul>
<h2 id="packages-used"><a class="header" href="#packages-used">Packages used</a></h2>
<ul>
<li><a href="https://github.com/raysan5/raylib">raylib v5.5</a></li>
</ul>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<pre><code class="language-bash"># build release
make release

# build debug version
make debug
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technical-choices"><a class="header" href="#technical-choices">Technical choices</a></h1>
<h2 id="chosen-language"><a class="header" href="#chosen-language">Chosen Language</a></h2>
<p>We chose C++ because for a multiplayer game, we needed very good performance.
The low-level control over memory allows us to optimize our game as much as possible.</p>
<p>Compared to Java, C# or Zig, we lose a bit of development time but it's worth it thanks to the time we gain on execution speed and resource control.</p>
<h2 id="chosen-graphical-library"><a class="header" href="#chosen-graphical-library">Chosen Graphical Library</a></h2>
<p>For our graphical library, we chose <a href="https://www.raylib.com/">Raylib</a>.</p>
<p>It offers multiple advantages compared to other libraries:</p>
<ol>
<li><strong>SFML</strong>
<ul>
<li>The raylib offers a higher level management of operations, with a lot of underlying global variables, offering nice and straightforward function calls.</li>
<li>The SFML, although having the nice advantage of being adapted to Object Oriented Programming, tends to be more difficult to use because of the need to keep track of all variables created. It may be preferable to have the variables in hand, but in our case with the ECS and state machine, we chose to have hidden variables.</li>
</ul>
</li>
<li><strong>SDL</strong>
<ul>
<li>The SDL is a low-level graphical library. We did not wanted to go too deep in that rabbit hole, and we stuck to the Raylib, offering higher level implementation.</li>
</ul>
</li>
<li><strong>Direct OpenGl calls</strong>
<ul>
<li>I'm not even gonna explain why we did not chose that path.</li>
</ul>
</li>
</ol>
<p>The Raylib is a really good graphical library, but we may encounter some problem with it, namely :</p>
<ul>
<li>It is not really adapted to Object Oriented Programming.<br />
Indeed, it is not at all constructed with classes, and rely solely on direct calls to global funtions</li>
</ul>
<h2 id="algorithms-and-data-structures"><a class="header" href="#algorithms-and-data-structures">Algorithms and Data Structures</a></h2>
<h3 id="ecs-entity-component-system"><a class="header" href="#ecs-entity-component-system">ECS (Entity Component System)</a></h3>
<p>The ECS was a bit of an unusual choice but logical for us.
Compared to a classic object-oriented architecture with inheritance, the ECS organizes data contiguously in memory, which optimizes the CPU cache on both server and client side.</p>
<p>Concretely, instead of having "Player" or "Enemy" objects that are subclasses, we group all components of the same type together.</p>
<p>Result: when we update positions or Health, the iteration is much faster.
For a game with many simultaneous entities, it makes a huge difference.</p>
<h3 id="réseautype-custom"><a class="header" href="#réseautype-custom">RéseauType (custom)</a></h3>
<p>This is our most strongest yet assumed choice. Instead of using an existing cross-platform library, we developed our own network library. Why?</p>
<ul>
<li>We know how it works. If a bug appears, we can fix it ourselves without depending on an external community.</li>
<li>Generic libraries handle many cases we don't need. Our protocol is tailored for our needs - position packets, input packets, etc.</li>
<li>By controlling the protocol, we can implement packets specific to our game, whereas with an existing library we would have had to adapt to its functioning.</li>
</ul>
<p>The fact that we have our own network library allows us to integrate these checks directly into the protocol rather than adding them on top.</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>RéseauType uses binary serialization for packet transmission.</p>
<p>This section compares different serialization methods.</p>
<h3 id="binary-serialization-our-approach"><a class="header" href="#binary-serialization-our-approach">Binary Serialization (Our approach)</a></h3>
<p>Binary serialization converts packet data into bytes.</p>
<p>Packets are not stored permanently. They exist only during transmission between client and server.</p>
<p>It is fast and deterministic.</p>
<p>Both the client and server know exactly how to read and write packet data.</p>
<p>There is no parsing overhead, which makes it reliable for real-time communication.</p>
<p>Each packet has a fixed size.</p>
<p>This makes bandwidth usage predictable and efficient.</p>
<p>However, changing packet structure requires updating both client and server code.</p>
<p>The binary format is also difficult to debug since it is not human-readable. (Although RéseauType comes with a Logger to make debugging easy !)</p>
<h3 id="why-réseautype-uses-binary-serialization"><a class="header" href="#why-réseautype-uses-binary-serialization">Why RéseauType Uses Binary Serialization</a></h3>
<p>RéseauType prioritizes speed and bandwidth usage</p>
<p>Binary serialization provides the fastest transmission and smallest packet size, which is critical for real-time multiplayer games where latency matters.</p>
<p>JSON or Protocol Buffers are not optimal for real-time games where performance is the priority.</p>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>The only security challenge of the project is dealing with client output and preventing cheating.
Clients can be modified or replaced with malicious programs that send fake data to gain unfair advantages.</p>
<h3 id="server-authority"><a class="header" href="#server-authority">Server Authority</a></h3>
<p>The server has authority on everything. It does not trust the client at any point.</p>
<p>The client only sends its inputs.</p>
<p>he server calculates the player's position, health, score, and all game state.</p>
<p>The client does not determine its own position or any game logic.</p>
<p>This prevents clients from sending false position data or modifying their own stats.</p>
<p>Even if a cheater modifies their client, they can only send inputs, not results.</p>
<h3 id="connection-validation"><a class="header" href="#connection-validation">Connection Validation</a></h3>
<p>A client is disconnected when it does not connect properly using the RéseauType Client.</p>
<p>Although this connection method can be mimicked by a custom client, it does not give any advantage over using the RéseauType Client.</p>
<p>This prevents random programs from spamming the server without proper authentication.</p>
<h3 id="packet-validation"><a class="header" href="#packet-validation">Packet Validation</a></h3>
<p>Our system can disconnect a user based on the data received in a packet.</p>
<p>An anti-cheat system can easily be implemented by adding packet executors that detect suspicious behavior.</p>
<p>The server kicks off a player when it receives an unknown packet ID. It only accepts registered packets.</p>
<h3 id="data-integrity"><a class="header" href="#data-integrity">Data Integrity</a></h3>
<p>All packets are serialized in binary with fixed sizes. The server validates packet size before processing. If a packet is incomplete or malformed, it is discarded.</p>
<h3 id="further-security-axis"><a class="header" href="#further-security-axis">Further Security Axis</a></h3>
<h4 id="ddos-attacks"><a class="header" href="#ddos-attacks">DDoS Attacks</a></h4>
<p>RéseauType does not currently implement rate limiting or IP blocking. A malicious client could spam packets to overload the server</p>
<p>Rate limiting can be added to limit the number of packets per second per client.</p>
<h4 id="man-in-the-middle-attacks"><a class="header" href="#man-in-the-middle-attacks">Man-in-the-Middle Attacks</a></h4>
<p>RéseauType does not encrypt packets. An attacker on the same network could intercept and read packets, or modify them in transit</p>
<p>Adding encryption (TLS for TCP, DTLS for UDP) could prevent this and could be added.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-documentation"><a class="header" href="#client-documentation">Client Documentation</a></h1>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>The client represent the playable part of the project.</p>
<p>A client must connect to a given running server to work.</p>
<p>It has a Graphical User Interface to allow a human to play the game.</p>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The client is composed of two parts:</p>
<ul>
<li><a href="client/index.html#gui--logic">The GUI &amp; Logic</a><br />
This is where all of the logic and rendering happen.</li>
<li><a href="client/index.html#network">The Network</a><br />
This is where all communications with the server happen.</li>
</ul>
<p>The client is not responsible to determine anything except for user inputs.<br />
The position of the player is even determined by the server itself.</p>
<h2 id="gui--logic"><a class="header" href="#gui--logic">Gui &amp; Logic</a></h2>
<p>This part of a client is defined as a state machine.</p>
<p>In can be in one of those states:</p>
<ul>
<li><a href="client/index.html#connection-state">Connection</a></li>
<li><a href="client/index.html#in-lobby-state">Lobby</a></li>
<li><a href="client/index.html#in-game-state">Game</a></li>
</ul>
<h3 id="connection-state"><a class="header" href="#connection-state">Connection state</a></h3>
<p>Inside the connection state, the client is preparing the connections with the server.<br />
It first connect with a TCP socket, and then setups a UDP connection (and this is where the loading time arise).</p>
<p>It is separated from the rest to forbid interaction while this crucial step is still processing.</p>
<h3 id="in-lobby-state"><a class="header" href="#in-lobby-state">In lobby state</a></h3>
<p>When connected, you are added to a lobby.<br />
This is where you wait for your friends to connect to join the game together.</p>
<p>Inside the lobby, you have the possibility to request the start of the game, and force every player in the lobby to switch to the game state.</p>
<h3 id="in-game-state"><a class="header" href="#in-game-state">In game state</a></h3>
<p>Finally, the real state. The one where you can play.</p>
<p>This state starts with a loading time. This is unfortunate, as we wanted to have a dedicated state for loading all ressources before connecting to the game. It will be added in the future !</p>
<p>Here you have the possibility to see other players, enemies, bullets and, of course, to interact and play the game with you controls.</p>
<h3 id="composition-of-each-state"><a class="header" href="#composition-of-each-state">Composition of each state</a></h3>
<p>We are using an Entity Component System to make the game work. Both rendering and logic parts are using this ECS.</p>
<p>Given that, every state has it's own separated entities, components and systems.<br />
For example, the game state has a system dedicated to showing a bullet on the screen, whilst the connecting state really don't have any bullets !</p>
<p>The GUI is then separated from the LOGIC, via two interfaces.</p>
<ol>
<li>GUI
Inside this part, all of the rendering logic happen. We define every rendering systems, as well as rendering-related responses to network packets.</li>
<li>Logic
There we enter the logic side, like managing player inputs, deleting entities, instanciating new bullets, and so on.<br />
We have responses to server requests via the networking interface in this part.</li>
</ol>
<p>Technically we do have a last state, the GAME OVER state, but it is really a very quick deconnection state, as we do not have a game over screen yet.</p>
<h2 id="network"><a class="header" href="#network">Network</a></h2>
<p>The client utilizes network in an extensive manner, as it needs it for almost everything !<br />
Indeed, almost nothing is determined by the client itself for now, and it is uncapable of even computing the position of the player.<br />
Thus, it needs to receive those informations from the server.</p>
<p>We can differentiate three kind of communication between the server and the client :</p>
<ol>
<li><strong>Mandatory connection communications</strong><br />
This include the authentification of the UDP socket for example.</li>
<li><strong>Ponctual events</strong><br />
For example, when a player is killed, or an enemy spawns.</li>
<li><strong>Continuous datastream</strong><br />
For example, player and enemy positions, player inputs.</li>
</ol>
<p>The architecture with executors that totally abstracts differentiation between types of packet make it fairly easy to understand how to implement a reaction to a give packet.</p>
<h2 id="managers"><a class="header" href="#managers">Managers</a></h2>
<ul>
<li><strong>Client Manager</strong><br />
The client itself is manager through a <code>ClientManager</code>.<br />
This class creates all the necessary subclasses and managers to launch the game, connect to the server and close everything without memory leaks.<br />
It hosts the principal game loop and the state machine, and calls the subsequent update and render methods from a given state. It is responsible for the state change, although determined by the state themselves.</li>
<li><strong>Network Manager</strong><br />
The network manager inits the network thread. Inside this thread runs the network main loop, in change of calling the network library methods to connect to the server, poll events and send them.<br />
This manager also handles request of deconnections.</li>
<li><strong>Sound Manager</strong><br />
The sound manager is a specific GUI manager that loads, plays and unloads sound files into memory.<br />
It serves as a cache to avoid loading the same sound file multiple times.</li>
<li><strong>Texture Manager</strong><br />
The Texture manager does the same thing as the sound manager, but adapted for images loaded as GPU textures.</li>
</ul>
<h1 id="graphical-library"><a class="header" href="#graphical-library">Graphical library</a></h1>
<p>For our graphical library, we chose <a href="https://www.raylib.com/">Raylib</a>.</p>
<p>It offers multiple advantages compared to other libraries:</p>
<ol>
<li><strong>SFML</strong>
<ul>
<li>The raylib offers a higher level management of operations, with a lot of underlying global variables, offering nice and straightforward function calls.</li>
<li>The SFML, although having the nice advantage of being adapted to Object Oriented Programming, tends to be more difficult to use because of the need to keep track of all variables created. It may be preferable to have the variables in hand, but in our case with the ECS and state machine, we chose to have hidden variables.</li>
</ul>
</li>
<li><strong>SDL</strong>
<ul>
<li>The SDL is a low-level graphical library. We did not wanted to go too deep in that rabbit hole, and we stuck to the Raylib, offering higher level implementation.</li>
</ul>
</li>
<li><strong>Direct OpenGl calls</strong>
<ul>
<li>I'm not even gonna explain why we did not chose that path.</li>
</ul>
</li>
</ol>
<p>The Raylib is a really good graphical library, but we may encounter some problem with it, namely :</p>
<ul>
<li>It is not really adapted to Object Oriented Programming.<br />
Indeed, it is not at all constructed with classes, and rely solely on direct calls to global funtions.</li>
</ul>
<h1 id="diagrams"><a class="header" href="#diagrams">Diagrams</a></h1>
<h2 id="client-architecture-diagramv"><a class="header" href="#client-architecture-diagramv">Client architecture diagramv</a></h2>
<p><img src="client/./arch.png" alt="Client architecture" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtype-server"><a class="header" href="#rtype-server">RType Server</a></h1>
<p>The RType Server is the game server implementation that extends RéseauType's <code>Server</code> class.
It manages game sessions (limited to one right now), and player connections.</p>
<h1 id="server-responsibilities"><a class="header" href="#server-responsibilities">Server Responsibilities</a></h1>
<h2 id="game-state-management"><a class="header" href="#game-state-management">Game State Management</a></h2>
<p>The server maintains the authoritative game state.</p>
<p>It processes player inputs, updates entity positions, handles collisions, and manages game logic.</p>
<p>Clients receive updates from the server but cannot modify the game state directly.</p>
<h2 id="player-connection-handling"><a class="header" href="#player-connection-handling">Player Connection Handling</a></h2>
<p>When a player connects, the server creates a new client instance and assigns them a unique UUID.</p>
<p>The server tracks all connected players and removes them from the game when they disconnect.</p>
<h2 id="packet-processing"><a class="header" href="#packet-processing">Packet Processing:</a></h2>
<p>The server uses packet executors to handle different types of packets:</p>
<ul>
<li><code>CLIENT_INPUTS</code>: Processes player input and updates game state</li>
<li><code>GAME_START_REQUEST</code>: Starts a new game session</li>
<li>etc..</li>
</ul>
<h2 id="entity-synchronization"><a class="header" href="#entity-synchronization">Entity Synchronization</a></h2>
<p>The server broadcasts entity updates to all clients using packets like:</p>
<ul>
<li><code>POSITION_UPDATE</code>: Sends entity positions</li>
<li><code>HEALTH_UPDATE</code>: Sends health changes</li>
<li><code>NEW_PLAYER</code>, <code>NEW_BULLET</code>, <code>NEW_ENEMY</code>: Spawns new entities</li>
<li><code>DESPAWN_PLAYER</code>, <code>DESPAWN_BULLET</code>: Removes entities</li>
<li>etc..</li>
</ul>
<h2 id="server-authority-1"><a class="header" href="#server-authority-1">Server Authority</a></h2>
<p>The server validates all client inputs.</p>
<p>Players cannot send their own positions or modify game state directly.</p>
<p>The server calculates everything and sends results to clients.</p>
<h1 id="what-is-done"><a class="header" href="#what-is-done">What is done</a></h1>
<p>Currently, the server allows launching a multiplayer game session.
Players can see each other move around and shoot at enemies.</p>
<p>There are two types of enemies: small enemies and big bosses. Players can shoot at them.</p>
<p>When there are no more enemies on the field, they respawn again. Enemies spawn from the left side of the screen.
Players have health points. When all players die, the game is over.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-documentation-aka-réseautype"><a class="header" href="#network-documentation-aka-réseautype">Network Documentation (a.k.a RéseauType)</a></h1>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>RéseauType is the network library used by both the client and the server, written in C++.</p>
<p>Being developed by our own, it provides a high abstraction of common network utils, and makes communication easy and reliable.
RéseauType allows server-client communication by Packet.
Packets are defined inside the library, and are shared by both the server and client, in order for them to be synchronised.
Developers, who wish to use this library, can add any sort of datas to packets (*).
Every sent packet is being serialised, and transmited in binary. Those packets can either be transmitted through UDP, or TCP, depending on the implemented type of packet.
RéseauType supports multi-threading, and such without having a timeout on <code>poll</code> (unnecessary loops).
RéseauType sockets are non-blocking.
RéseauType, with its own Client and Server implementation, is able to match a TCP Client to an UDP Client, and recognise them as a single entity and same entity. This demonstrate RéseauType's high network abstraction.
RéseauType comes with its own logging packet system, logging every received and sent packet. Those can be toggled by setting <code>Logger:shouldLog</code> to <code>true</code></p>
<p>(*): except strings, those will be available in a future soon-to-be update.</p>
<h1 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h1>
<p>RéseauType is composed of five parts:</p>
<ul>
<li><a href="network/index.html#packets">Packets</a>
Packets are the data being sent from the server to the clients and vice-versa. Serialised in binary, those can be sent either via TCP or UDP.</li>
<li><a href="network/index.html#the-server">The Server</a><br />
Creates &amp; starts a RéseauType server (TCP/UDP) that can automatically write, receive, and execute packets.</li>
<li><a href="network/index.html#the-client">The Client</a><br />
Creates a client to connect to a RéseauType server (TCP/UDP). It can send, receive, and execute incoming packets from the server.</li>
<li><a href="network/index.html#poll-manager">PollManager</a>
PollManager is being used by both the client and server. It is a generic part of RéseauType, which allows to accept connections, read packets, send packets, and handle disconnections.</li>
<li><a href="network/index.html#packet-executors">Packet Executors</a>
RéseauType's Packet Executors allow you to run specific code when receiving a particular packet type.
These can be added to both the <code>Client</code> or the <code>Server</code>.</li>
</ul>
<h2 id="packets"><a class="header" href="#packets">Packets</a></h2>
<p>A packet is a serialisable data structure that can be sent between the client and the server using either TCP or UDP.
Each packet has an ID, is fixed sized, and withholds datas.
A packet does not have a direction, and can be sent by both the server and the client.
The server and the client needs to handle individually their own behavior on receiving a packet using <a href="network/index.html#packet-executors">Packet Executors</a></p>
<h3 id="developers-packet-definition-how-to-create-your-own-packet"><a class="header" href="#developers-packet-definition-how-to-create-your-own-packet">Developer's Packet Definition (How to create your own packet)</a></h3>
<p>Each created packet must implement the <code>Packet</code> class.</p>
<h4 id="id"><a class="header" href="#id">ID</a></h4>
<p>First and foremost, a packet needs a unique ID, which cannot exceed the length of a <code>uint8_t</code>.
This ID must be set using the herited <code>Packet</code> constructor.</p>
<pre><code class="language-cpp">class ExamplePacket : public Packet {
public:
   ExamplePacket(uint32_t uuid=0) : Packet(PacketId::S_AUTHENTICATION_PACKET) {
        this-&gt;uuid = uuid;
    }
};
</code></pre>
<p><strong>/!:</strong> DO NOT USE A SAME ID FOR TWO PACKETS, IT IS AN UNDEFINED BEHAVIOR.
You are free to set a custom constructor for each of your packets. However, you <strong>MUST</strong> ensure your packet can be instantiated without any constructor arguments.</p>
<h4 id="serialisation--unserialisation"><a class="header" href="#serialisation--unserialisation">Serialisation &amp; Unserialisation</a></h4>
<p>A packet is supposed to send one or multiple datas as a single packet. Therefore, you <strong>NEED</strong> to implement the two following methods:</p>
<pre><code class="language-cpp">void serialize() {
   /* Serialisation code goes here */
}

void unserialize() {
   /* Unerialisation code goes here */
}
</code></pre>
<p><code>serialize()</code> is the function called to <strong>send the packet</strong>.
On the other hand, <code>unserialize</code> is the function being called to turn a <code>serialised</code> binary data into the original <code>Packet</code></p>
<p>If the packet had to send in order:</p>
<ul>
<li>An integer, called <code>meow</code>.</li>
<li>A double, called <code>woof</code></li>
<li>Yet another integer, called <code>uwu</code></li>
</ul>
<p>This is how the <code>serialize()</code> function <strong>MUST</strong> be implemented:</p>
<pre><code class="language-cpp">class ExamplePacket : public Packet {
public:
   /* [...] Constructor with Packet's ID definition */

   void serialize() {
      this-&gt;write(meow);
      this-&gt;write(woof);
      this-&gt;write(uwu);
   }
private:
   int meow = 69;
   double woof = 727.420;
   int uwu = 67;
};
</code></pre>
<p>The <code>write</code> function is a pre-implemented <code>Packet</code> method and allows for data types to be easily written.
As a result, our packet upon sending, will send in order the value of <code>meow</code>, <code>woof</code>, then finally <code>uwu</code>.</p>
<p>However, if our packet can be sent, it still can not be converted back into our original packet as we did not implement the <code>unserialise()</code> method.</p>
<p>This is how the <code>unserialise()</code> function <strong>MUST</strong> be implemented:</p>
<pre><code class="language-cpp">class ExamplePacket : public Packet {
public:
   /* [...] Constructor with Packet's ID definition */

   void serialize() {
      this-&gt;write(meow);
      this-&gt;write(woof);
      this-&gt;write(uwu);
   }

   void unserialize() {
      this-&gt;read(meow);
      this-&gt;read(woof);
      this-&gt;read(uwu);
   }
private:
   int meow = 69;
   double woof = 727.420;
   int uwu = 67;
};
</code></pre>
<p>The <code>read</code> function is a pre-implemented <code>Packet</code> method and allows for data types to be easily read.
As a result, our packet upon receiving, will read in order the value of <code>meow</code>, <code>woof</code>, then finally <code>uwu</code>, which <strong>MUST</strong> be in the same order that they were <strong>serialized</strong>.
<code>meow</code>, <code>woof</code> and <code>uwu</code>'s value will then be set to their corresponding received values.</p>
<h4 id="size"><a class="header" href="#size">Size</a></h4>
<p>This is one of the two's biggest RéseauType's flaw, and will be updated very soon.
Each packet must declare its data size manually in a <code>getSize() const</code> function</p>
<p>If we had to take our previous example, its size would be <code>sizeof(int) + sizeof(double) + sizeof(int)</code> which is <code>sizeof(int) * 2 + sizeof(double)</code></p>
<p>Thus, our packet <code>getSize()</code> function would have to be implemented as:</p>
<pre><code class="language-cpp">int getSize() const {
   return (int) sizeof(int) * 2 + sizeof(double);
}
</code></pre>
<h4 id="name"><a class="header" href="#name">Name</a></h4>
<p>This only serves for the <code>Logger</code> and as an <code>identifier</code> for the user. Each packet must specify its packet name by implementing the following method:</p>
<pre><code class="language-cpp">const std::string getName() {
   return "ExamplePacket";
}
</code></pre>
<h4 id="mode"><a class="header" href="#mode">Mode</a></h4>
<p>This indicates if the packet should be sent using <code>TCP</code> or <code>UDP</code> to the target.</p>
<pre><code class="language-cpp">enum PacketMode getMode() const {
   return PacketMode::TCP;
}
</code></pre>
<p>or</p>
<pre><code class="language-cpp">enum PacketMode getMode() const {
   return PacketMode::UDP;
}
</code></pre>
<h4 id="display"><a class="header" href="#display">Display</a></h4>
<p>This is also something that needs to change and will be soon discarded.
Each packet needs to implement a <code>display</code> method and displays all of its value inside for the logger to display them.</p>
<p>If we had to take our <code>ExamplePacket</code>, this would be a way to implement that method:</p>
<pre><code class="language-cpp">void display() {
   std::cout &lt;&lt; "meow=" &lt;&lt; this-&gt;meow &lt;&lt; ", woof=" &lt;&lt; this-&gt;woof &lt;&lt; ", uwu=" &lt;&lt; this-&gt;uwu;
}
</code></pre>
<p>which would print all of the received values.</p>
<h4 id="clone"><a class="header" href="#clone">Clone</a></h4>
<p>This is a repetitive method that should be implemented in every packet as a way for the user to be able to clone a packet if needed.</p>
<pre><code class="language-cpp">std::shared_ptr&lt;Packet&gt; clone() const {
   return make_copy(ExamplePacket);
}
</code></pre>
<p>simply return <code>make_copy</code> and use as a parameter the <code>class name</code> of the <code>Packet</code>.</p>
<h3 id="packets-registering"><a class="header" href="#packets-registering">Packet's Registering</a></h3>
<p>After implementing your own packet, you will need to <strong>register</strong> your packet.
For doing such process, you will need to add it to the <code>PacketManager</code> class.
This will register the packet in both the client and server, and will be able to be used.
On the <code>PacketManager</code>'s <code>registerPackets</code> method, simply add a line</p>
<pre><code class="language-cpp">this-&gt;packets.push_back(std::make_shared&lt;ExamplePacket&gt;());
</code></pre>
<p>And our packet can now be used by the server and client easily !</p>
<h2 id="the-server"><a class="header" href="#the-server">The Server</a></h2>
<p>The Server is RéseauType's core component that handles both TCP and UDP connections.
It manages client connections, receives, sends packets, and can execute packet handlers automatically.</p>
<h3 id="servers-definition"><a class="header" href="#servers-definition">Server's Definition</a></h3>
<p>You need to create your own server by implementing the Server class, and the three following functions:</p>
<pre><code class="language-cpp">virtual std::shared_ptr&lt;IPollable&gt; createClient(int fd) = 0;
virtual void onClientConnect(std::shared_ptr&lt;IPollable&gt; client) = 0;
virtual void onClientDisconnect(std::shared_ptr&lt;IPollable&gt; client) = 0;
</code></pre>
<ul>
<li><code>onClientConnect</code> will be invoked when a client connects to the server.</li>
<li><code>onClientDisconnect</code> will be invoked when a client disconnects from the server.</li>
<li><code>createClient</code> is the way you want clients to be created (if you wish to use a custom class).
However, it is best if it implements ServerClient rather than IPollable (which itself already implements IPollable and does more things)</li>
</ul>
<p>If you do not wish to create your own Server class and make it implement <code>Server</code> class, you can use the default <code>CustomServer</code> on the library, which is defined the following way:</p>
<pre><code class="language-cpp">class CustomServer : public Server {
    public:
        CustomServer(int port) : Server(port) {
            return;
        }

        std::shared_ptr&lt;IPollable&gt; createClient(int fd) {
            return std::make_shared&lt;ServerClient&gt;(fd, *this);
        }

        void onClientConnect(std::shared_ptr&lt;IPollable&gt; client) {
            LOG("Client [" &lt;&lt; client-&gt;getFileDescriptor() &lt;&lt; "] connected !");
        }

        void onClientDisconnect(std::shared_ptr&lt;IPollable&gt; client) {
            LOG("Client [" &lt;&lt; client-&gt;getFileDescriptor() &lt;&lt; "] disconnected !");
        }
};
</code></pre>
<h3 id="servers-methods"><a class="header" href="#servers-methods">Server's methods</a></h3>
<h4 id="up"><a class="header" href="#up">up()</a></h4>
<p>Starts the server on the specified port. Creates both TCP and UDP sockets, and begins listening for connections.
Returns <code>true</code> if the server started successfully, <code>false</code> otherwise.</p>
<h4 id="down"><a class="header" href="#down">down()</a></h4>
<p>Stops the server. Shuts down both TCP and UDP sockets, clears all connections, and removes all packet executors.
Returns <code>true</code> if the server stopped successfully, <code>false</code> otherwise.</p>
<h4 id="isup"><a class="header" href="#isup">isUp()</a></h4>
<p>Returns <code>true</code> if the server is currently running, <code>false</code> otherwise.</p>
<h4 id="loop"><a class="header" href="#loop">loop()</a></h4>
<p>Main server loop that handles all network operations:</p>
<ul>
<li>Sends UDP packets</li>
<li>Polls for socket events</li>
<li>Handles client disconnections</li>
<li>Executes received packets</li>
</ul>
<p>This method <strong>MUST</strong> be called repeatedly while the server is running.</p>
<h4 id="getpacketlistener"><a class="header" href="#getpacketlistener">getPacketListener()</a></h4>
<p>Returns the server's packet listener, which allows you to add packet executors for handling received packets.</p>
<h4 id="getpollmanager"><a class="header" href="#getpollmanager">getPollManager()</a></h4>
<p>Returns the server's poll manager, which handles all socket polling and connection management.</p>
<h4 id="getmaxconnections"><a class="header" href="#getmaxconnections">getMaxConnections()</a></h4>
<p>Returns the maximum number of simultaneous connections the server can handle.</p>
<h3 id="servers-client"><a class="header" href="#servers-client">Server's Client</a></h3>
<p>A connected client is a <code>Pollable</code>.
Although, a <code>Pollable</code> is not necessarily a <code>client</code></p>
<p>The base pollable class for server clients is <code>ServerClient</code>.
This class provides a <code>sendPacket()</code> method to send a packet to a connected client.</p>
<h3 id="servers-udp-authentication"><a class="header" href="#servers-udp-authentication">Server's UDP Authentication</a></h3>
<p>When a client connects to the server via TCP, the server generates a unique UUID and sends it to the client using a <code>SAuthentificationPacket</code>.</p>
<p>The server then waits to receive this UUID back from the client via UDP through a <code>CAuthentificationPacket</code>.</p>
<p>Once received, the server binds the TCP and UDP connections together, recognizing them as a single client entity.
After successful authentication, the server sends an <code>AuthentifiedPacket</code> to the client on the TCP connection to confirm the authentication was successful.
Only then can the client and server exchange UDP packets.</p>
<h2 id="the-client"><a class="header" href="#the-client">The Client</a></h2>
<p>The Client is RéseauType's component that connects to a server using both TCP and UDP.
It handles connection establishment, packet sending and receiving, and executes packet handlers automatically.</p>
<h3 id="clients-methods"><a class="header" href="#clients-methods">Client's methods</a></h3>
<h4 id="connect"><a class="header" href="#connect">connect()</a></h4>
<p>Connects the client to the server at the specified IP and port.
Creates both TCP and UDP sockets and establishes connections
Returns <code>true</code> if the connection was successful, <code>false</code> otherwise.</p>
<h4 id="disconnect"><a class="header" href="#disconnect">disconnect()</a></h4>
<p>Disconnects the client from the server.
Closes both TCP and UDP sockets
Clears all connections, and removes all packet executors.
Returns <code>true</code> if the disconnection was successful.</p>
<h4 id="isconnected"><a class="header" href="#isconnected">isConnected()</a></h4>
<p>Returns <code>true</code> if the client is currently connected to the server, <code>false</code> otherwise.</p>
<h4 id="sendpacket"><a class="header" href="#sendpacket">sendPacket()</a></h4>
<p>Sends a packet to the server.
The packet will be sent through TCP or UDP depending on its mode.</p>
<h4 id="loop-1"><a class="header" href="#loop-1">loop()</a></h4>
<p>Main client loop that handles all network operations:</p>
<ul>
<li>Sends UDP packets</li>
<li>Polls for socket events</li>
<li>Executes received packets.</li>
</ul>
<p>This method <strong>MUST</strong> be called repeatedly while the client is connected.</p>
<h4 id="getpacketlistener-1"><a class="header" href="#getpacketlistener-1">getPacketListener()</a></h4>
<p>Returns the client's packet listener, which allows you to add packet executors for handling received packets.</p>
<h4 id="getpollmanager-1"><a class="header" href="#getpollmanager-1">getPollManager()</a></h4>
<p>Returns the client's poll manager, which handles all socket polling and connection management.</p>
<h4 id="getip"><a class="header" href="#getip">getIp()</a></h4>
<p>Returns the server's IP address the client is connected to.</p>
<h4 id="getport"><a class="header" href="#getport">getPort()</a></h4>
<p>Returns the server's port the client is connected to.</p>
<h4 id="isauthentified"><a class="header" href="#isauthentified">isAuthentified()</a></h4>
<p>Returns <code>true</code> if the client has been authenticated by the server, <code>false</code> otherwise.</p>
<h4 id="getuuid"><a class="header" href="#getuuid">getUUID()</a></h4>
<p>Returns the unique identifier assigned to this client by the server.</p>
<h3 id="clients-udp-authentication"><a class="header" href="#clients-udp-authentication">Client's UDP Authentication</a></h3>
<p>When the client connects to the server via TCP, it receives a <code>SAuthentificationPacket</code> which contains an UUID.
The client sends this UUID to the server via UDP using a <code>CAuthentificationPacket</code>.</p>
<p>This process binds the TCP and UDP connections together, allowing the server to recognize them as a single client.</p>
<p>If this authentication fails, the client cannot send or receive any UDP packets.
The client will retry sending the <code>CAuthentificationPacket</code> up to 10 times.
The client only knows if it has been successfully authenticated when it receives an <code>AuthentifiedPacket</code> from the server on the TCP end.</p>
<h2 id="pollmanager"><a class="header" href="#pollmanager">PollManager</a></h2>
<p>The PollManager is RéseauType's component that handles socket polling and connection management.
It is used by both the server and the client to manage all active connections and poll for network events.</p>
<p>Overexplaining this component is not useful, as it is made to never be <strong>edited</strong>.</p>
<h3 id="pollmanagers-methods"><a class="header" href="#pollmanagers-methods">PollManager's methods</a></h3>
<h4 id="addpollable"><a class="header" href="#addpollable">addPollable()</a></h4>
<p>Adds a new pollable connection to the manager.</p>
<h4 id="removepollable"><a class="header" href="#removepollable">removePollable()</a></h4>
<p>Removes a pollable connection by its file descriptor.
Closes the socket and returns the removed pollable.</p>
<h4 id="removepollables"><a class="header" href="#removepollables">removePollables()</a></h4>
<p>Removes multiple pollable connections at once.
Returns a vector of the removed pollables.</p>
<h4 id="updateflags"><a class="header" href="#updateflags">updateFlags()</a></h4>
<p>Updates the polling flags for a specific file descriptor.</p>
<h4 id="getconnectioncount"><a class="header" href="#getconnectioncount">getConnectionCount()</a></h4>
<p>Returns the total number of active connections.
(This sadly includes more than the number of connected clients to the server and needs to be changed).</p>
<h4 id="getpool"><a class="header" href="#getpool">getPool()</a></h4>
<p>Returns all active the active pollable connections.</p>
<h4 id="getpollablebyaddress"><a class="header" href="#getpollablebyaddress">getPollableByAddress()</a></h4>
<p>Returns a pollable connection by its network address.
Returns nullptr if not found.</p>
<h4 id="pollsockets"><a class="header" href="#pollsockets">pollSockets()</a></h4>
<p>Polls all registered sockets for events.
Takes an optional timeout in milliseconds.
Returns a vector of pollables that disconnected during the poll.</p>
<h4 id="wakeup"><a class="header" href="#wakeup">wakeUp()</a></h4>
<p>Wakes up the poll if it is currently blocking (useful for multi-threading purposes).</p>
<h4 id="clear"><a class="header" href="#clear">clear()</a></h4>
<p>Removes all pollables and closes all sockets.
Called when shutting down either the server or client.</p>
<h2 id="packet-executors"><a class="header" href="#packet-executors">Packet Executors</a></h2>
<p>Packet Executors allow you to run specific code when receiving a particular packet type.
They are event handlers that get triggered automatically when a packet is received by the server or client.</p>
<p>In order to explain them properly, we will take as an example the following case:
We want to print on the console <code>"meow !!! :3 &gt;\\&lt; {uwu}"</code> if <code>ExamplePacket</code> was being sent
<code>{uwu}</code> being the uwu value of the <code>ExamplePacket</code> which can be retrieved using a <code>int getUwU() const;</code> method.</p>
<h3 id="packet-executors-server-implementation"><a class="header" href="#packet-executors-server-implementation">Packet Executor's Server Implementation</a></h3>
<p>Each Server's executor must implement the <code>PacketExecutorImplServer</code> class</p>
<p><code>PacketExecutorImplServer</code> class is a template class that takes two dynamic types : The first one being the type of packet of the executor (in our case, <code>ExamplePacket</code>) and the second being the type of the client that will send us the packet (in our case <code>ServerClient</code> (which is the default))</p>
<pre><code class="language-cpp">class AwesomeExamplePacketExecutor : public PacketExecutorImplServer&lt;ExamplePacket, ServerClient&gt; {
   /* Code.... */
};
</code></pre>
<p>A class that implements <code>PacketExecutorImplServer</code> must define two methods : an <code>execute(...)</code> and a <code>getPacketId()</code></p>
<p><code>getPacketId()</code> is the ID of the packet that will be catched (<code>ExamplePacket</code> in our example)
<code>execute(....)</code> is the method that will be called when receiving an <code>ExamplePacket</code></p>
<p>Those two functions when implemented looks like the following:</p>
<pre><code class="language-cpp">class AwesomeExamplePacketExecutor : public PacketExecutorImplServer&lt;ExamplePacket, ServerClient&gt; {
   bool execute(Server &amp;srv, std::shared_ptr&lt;ServerClient&gt; con, std::shared_ptr&lt;ExamplePacket&gt; packet) {
      /* Code */
      return true;
   }

    int getPacketId() const {
        return PacketId::NEW_PLAYER;
    }
};
</code></pre>
<p>The <code>execute</code> function takes:</p>
<ul>
<li>As a first parameter, the <code>Server</code>.</li>
<li>As a second parameter, a <code>shared_ptr</code> of the specified Client Class.</li>
<li>And at last, a <code>shared_ptr</code> of the received packet</li>
</ul>
<p>The return type of <code>execute</code> determines whether the client should be disconnected or no.</p>
<p>As <code>execute</code> is the function being called when an <code>ExamplePacket</code> is being received, we only need to write what we had to write on the console the following way:</p>
<pre><code class="language-cpp">bool execute(Server &amp;srv, std::shared_ptr&lt;ServerClient&gt; con, std::shared_ptr&lt;ExamplePacket&gt; packet) {
   (void) srv;
   (void) con;
   std::cout &lt;&lt; "meow !!! :3 &gt;\\&lt; " &lt;&lt; packet.getUwU() &lt;&lt; std::endl;
   return true;
}
</code></pre>
<h3 id="packet-executors-client-implementation"><a class="header" href="#packet-executors-client-implementation">Packet Executor's Client Implementation</a></h3>
<p>Each Client's executor must implement the <code>PacketExecutorImplClient</code> class</p>
<p><code>PacketExecutorImplClient</code> class is a template class that takes two dynamic types : The first one being the type of packet of the executor (in our case, <code>ExamplePacket</code>) and the second being the type of the client that will send us the packet (which <strong>MUST</strong> always be ClientPollable)
P.S: This second forced parameter will be removed in an soon upcoming update.</p>
<pre><code class="language-cpp">class AwesomeExamplePacketExecutor : public PacketExecutorImplClient&lt;ExamplePacket, ClientPollable&gt; {
   /* Code.... */
};
</code></pre>
<p>A class that implements <code>PacketExecutorImplClient</code> must define two methods : an <code>execute(...)</code> and a <code>getPacketId()</code></p>
<p><code>getPacketId()</code> is the ID of the packet that will be catched (<code>ExamplePacket</code> in our example)
<code>execute(....)</code> is the method that will be called when receiving an <code>ExamplePacket</code></p>
<p>Those two functions when implemented looks like the following:</p>
<pre><code class="language-cpp">class AwesomeExamplePacketExecutor : public PacketExecutorImplClient&lt;ExamplePacket, ClientPollable&gt; {
   bool execute(Client &amp;cl, std::shared_ptr&lt;ClientPollable&gt; con, std::shared_ptr&lt;ExamplePacket&gt; packet) {
      /* Code */
      return true;
   }

    int getPacketId() const {
        return PacketId::NEW_PLAYER;
    }
};
</code></pre>
<p>The <code>execute</code> function takes:</p>
<ul>
<li>As a first parameter, the <code>Client</code>.</li>
<li>As a second parameter, a <code>shared_ptr</code> of the specified Client Class.</li>
<li>And at last, a <code>shared_ptr</code> of the received packet</li>
</ul>
<p>The return type of <code>execute</code> determines whether the client should be disconnected or no.</p>
<p>As <code>execute</code> is the function being called when an <code>ExamplePacket</code> is being received, we only need to write what we had to write on the console the following way:</p>
<pre><code class="language-cpp">bool execute(Server &amp;srv, std::shared_ptr&lt;ServerClient&gt; con, std::shared_ptr&lt;ExamplePacket&gt; packet) {
   (void) srv;
   (void) con;
   std::cout &lt;&lt; "meow !!! :3 &gt;\\&lt; " &lt;&lt; packet.getUwU() &lt;&lt; std::endl;
   return true;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecs-usage-guide"><a class="header" href="#ecs-usage-guide">ECS Usage Guide</a></h1>
<p>An Entity Component System works with 3 types :</p>
<ul>
<li>Entities</li>
<li>Components</li>
<li>Systems</li>
</ul>
<p>A Component is a small storage structure.<br />
It should define a single component out of a more complex set, representing an Entity.</p>
<p>As said, an Entity is represented by a set of components, which can be dynamically modified.</p>
<p>And a System is something that you would apply on all entities satisfying certain Components, to allow for modification, rendering, ...</p>
<p>For example, if you have a component Position and Velocity, you could have a System to update the Position based on the Velocity, and a lot of very different entities could end up with those components and be moved by the same System.</p>
<p>The goal is to separate every actions, and to maximize performances.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<ol>
<li>Define Components
Components are simple data structures.</li>
</ol>
<pre><code class="language-cpp">struct Position {
    int x;
    int y;
};
</code></pre>
<ol start="2">
<li>Create Systems<br />
Systems are functions that process components.</li>
</ol>
<pre><code class="language-cpp">void logging_system(Registry&amp; r,
    containers::indexed_zipper&lt;SparseArray&lt;Position&gt;,
                               SparseArray&lt;Velocity&gt;&gt; zipper)
{
    for (auto&amp;&amp; [i, pos, vel] : zipper)
        std::cerr &lt;&lt; i &lt;&lt; ": Position = { " &lt;&lt; pos.value().x &lt;&lt; ", "
                  &lt;&lt; pos.value().y &lt;&lt; " }" &lt;&lt; std ::endl;
        std::cerr &lt;&lt; i &lt;&lt; ": Velocity = { " &lt;&lt; vel-&gt;x &lt;&lt; ", "
                  &lt;&lt; vel-&gt;y &lt;&lt; " }" &lt;&lt; std ::endl;
}
</code></pre>
<ol start="3">
<li>Setup Registry<br />
The registry holds the ECS.</li>
</ol>
<pre><code class="language-cpp">Registry r;
r.register_component&lt;Position&gt;();
r.register_component&lt;Velocity&gt;();
</code></pre>
<ol start="4">
<li>Create Entities</li>
</ol>
<pre><code class="language-cpp">Entity player = r.spawn_entity();
</code></pre>
<ol start="5">
<li>Add Components to Entities</li>
</ol>
<pre><code class="language-cpp">r.emplace_component&lt;Position&gt;(player, 2, 23);
r.emplace_component&lt;Velocity&gt;(player, 1, 0);
</code></pre>
<ol start="6">
<li>Register and Run Systems</li>
</ol>
<pre><code class="language-cpp">r.add_{render/update}_system&lt;Position, Velocity&gt;(logging_system);
r.{render/update}();
</code></pre>
<ol start="7">
<li>Cleanup</li>
</ol>
<pre><code class="language-cpp">r.kill_entity(player);
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>See the file <code>ecs/ecs_exemple.cpp</code></p>
<h2 id="iterating-over-components"><a class="header" href="#iterating-over-components">Iterating Over Components</a></h2>
<p>Use zipper to iterate over multiple component arrays:</p>
<pre><code class="language-cpp">
// With index
for (auto&amp;&amp; [i, pos, vel] : containers::indexed_zipper(positions, velocities)) {
    // i is the entity ID
}
</code></pre>
<h2 id="passing-more-parameters-to-systems"><a class="header" href="#passing-more-parameters-to-systems">Passing more parameters to systems</a></h2>
<p>You can simply add more parameters to systems when registering them.</p>
<pre><code class="language-cpp">void system([[maybe_unused]] Registry &amp;r,
    [[maybe_unused]] containers::indexed_zipper&lt;SparseArray&lt;Position&gt;&gt; zipper,
    int bonus_parameter)
{
    std::cout &lt;&lt; "Int value=" &lt;&lt; bonus_parameter &lt;&lt; std::endl;
}

// Inside function to register systems
registry.add_render_system&lt;Position&gt;(12); // 12 will be passed as bonus_parameter
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="graphical-library-1"><a class="header" href="#graphical-library-1">Graphical Library</a></h2>
<h1 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h1>
<p>The Graphical Library imposes restrictions.</p>
<ol>
<li>All methods must be called in a single Thread.</li>
<li>The <code>init</code> method must be called before any other method.</li>
<li>The <code>deinit</code> method must be called before the object is deconstructed.</li>
</ol>
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<h2 id="rectangle"><a class="header" href="#rectangle">Rectangle</a></h2>
<p>In order to draw a rectangle, you need to create a <code>Rectangle</code> object, and then call the <code>draw</code> method with that rectangle.</p>
<p>You can specify three parameters.</p>
<ol>
<li>The on-screen position with <code>position</code>, as a <code>WorldPosition</code> object.</li>
<li>The on-screen size with <code>size</code>, as a <code>Vector2ui</code> object.</li>
<li>The color with <code>color</code>.</li>
</ol>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>In order to draw text on screen, you need to create a <code>Text</code> object, and then call the <code>draw</code> method with that text.</p>
<p>To help center the text, you can use the <code>getTextWidth</code> method to get the width of the text in on-screen pixels, using either a <code>Text</code> object, or just plain text with a fontSize.</p>
<p>You cannot change the text font.</p>
<p>You can choose the text, it's on-screen position, font size and color.</p>
<h2 id="images"><a class="header" href="#images">Images</a></h2>
<p>Images are called Textures.</p>
<p>Textures are referenced by name as a <code>std::string</code>.</p>
<p>The best way to use Textures is to register them using the <code>registerTexture</code> method, by specifying a path to the texture file, and a name to reference it ; then to load all textures with <code>loadAllTextures</code> at a specified time.<br />
This way, you will have a lag at the loading time, but not in random state change. You could load all textures in a dedicated "Loading" screen for example.</p>
<p>If you prefer, you can load a single texture instantly using the <code>loadTexture</code> method.</p>
<p>You can get a loaded texture through the <code>getTexture</code> method.</p>
<p>You can render a <code>Texture</code> object via the <code>draw</code> method.</p>
<p>To position the texture to draw, modify a copy of the <code>Texture</code> object.</p>
<p>You have write access to :</p>
<ol>
<li>The <code>scale</code> attribute, to scale up or down the texture. 1.0 is the default scale.</li>
<li>The <code>pos</code> attribute, to set the on-screen position.</li>
<li>The <code>rotation</code> attribyte, to set the rotation in degrees.</li>
</ol>
<p>You have read access to :</p>
<ol>
<li>The <code>path</code> attribute, specifying the texture file path.</li>
<li>The <code>name</code> attribute, specifying the texture reference name.</li>
<li>The <code>size</code> attribute, specifying the on-screen size for a scale of 1.</li>
</ol>
<h2 id="sound"><a class="header" href="#sound">Sound</a></h2>
<p>Like textures, sound can be registered for loading, or loaded directly following similar conventions.</p>
<p>You only have read access on the <code>Sound</code> object, allowing the reading of the file path and reference name.</p>
<p>A sound is played using the <code>play</code> method.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Events are used to know if a key is pressed, down or just up.</p>
<p>You can register a list of events with the <code>registerEvent</code> method.<br />
Events are referenced by name in the form of a <code>std::string</code>.</p>
<p>If you want to deactivate an event, bind it to the <code>gl::Key::UNDEFINED</code> key.</p>
<p>You can re-bind events using the <code>bindKey</code> method.</p>
<p>If the key bound to an event was pressed in the current frame but not in the precedent frame, the <code>isEventStart</code> method should yield <code>true</code>.</p>
<p>If the key bound to an event is currently pressed, the <code>isEventActive</code> method should yield <code>true</code>.</p>
<p>In other cases, or if the event is deactivated, the <code>isEvent{Start,Active}</code> methods should yield false.</p>
<h2 id="render-loop"><a class="header" href="#render-loop">Render loop</a></h2>
<p>The render loop should be implemented at a higher order.</p>
<p>If the window was closed, the <code>should_close</code> method returns <code>true</code>.<br />
You should not call any methods other than <code>end_frame</code> or <code>deinit</code> in this case.</p>
<p>Any render methods should be called between the call of <code>start_new_frame</code> and <code>end_frame</code>.</p>
<p>A typical implementation would be like the following :</p>
<pre><code class="language-c++">gl.init();
/*
Register events
Register textures
Register sounds
*/
gl.loadEverything();
while (!gl.should_close()) {
    gl.start_new_frame(gl::BLACK);
    /*
    Drawing code here
    */
    gl.end_frame();
}
gl.deinit();
</code></pre>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<p>When using textures and sound, we recommand using the <code>loadEverything</code> method, loading both registered textures and sounds.</p>
<p>If you need to get the window size, use the <code>get_window_size</code> method.</p>
<p>If you need to get the delta time between the last frame, use the <code>getDeltaTime</code> method.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>An implementation was done using the <code>Raylib</code> library, and can be found in the <code>graphical_library/raylib/</code> directory.</p>
<p>You can instanciate it in a cpp file using the following :</p>
<pre><code class="language-c++">#include &lt;graphical_library/raylib/Raylib.hpp&gt;

std::make_unique&lt;Raylib&gt;();
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
